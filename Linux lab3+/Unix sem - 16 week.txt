Предпоследний семинар ОС
Сигналы программные каналы - было в лабе 4. Щас будет уточняющая инфа - будет на экзамене.
Сиганлы: классическое средство информирования процессов в системе и в процессах
Базовые идею Юникс остались неизменными. Процессы реального времени в ОС общего назначения
Они переписываются под новое время, модифицируются. 
с версии 2.6 линукс поддерживает многоядерность, с появлением нескольких ядер в процах ОС пришлось переписать координально
******
В классик Юниксе кол-во сигналов максимум 20, сейчас намного больше
наиболее часто получение процессом сигнала - приписывает этому процессу завершиться
Механизм сигналов позволяет процам реагировать процессам кот происходят внутри или снаружи его, как правило получение сигнала это указ на завершение
Вместе с тем, реакция проца - зависит от того как сам сингал определяет эту реакцию**
Сигнал процессом может быть проигнорирован -SIG_IGN
отреагировать по умолчанию - SID_DFL
или определить собственную реакцию на полученный сигнал
средством посылки и премаа сигналов  2 в Юниксе - 
kill: int kill(int pid, int sig)
Пример вызова: 
kill(getpid(),SIGALARM);
Выполнив этот вызов - сам процесс вызвавший процесс (getpid) будет уничтожен сигналом
Системный вызов сигнала: 
#include <singal.h>
void(*singnal(int sig, void(*handler)(int)))(int), //реакция процесса на сигнал - вызов обработчика handler

Системый сигнал нельзя использовать в переносимых приложениях, так как его поведение в разных системах (какие-то Юникс дистрибутивы) отличаются.
Системый сигнал возвращает сигнал на предыдущий обработчик сигнала, в силу этого его можно использовать для восстановления обработчика сигнала.

#include <signal.h>
int main(){
void(*old_handler)(int)=signal(SIGINIT,SIG_ICN);
/*........*/
signal(SIGINIT, olf_handler);
}

selection - входит в POSIX 1, и соотвественно входит во все сис-мы которые поддерживают его

#include <signal.h> //- таже библиотека, но формат вызова отличный.
int sigaction(int sig_num, struct sigaction *action, struct sigaction *old.action);

sigsetjmp() - отмечает одну или несколько позиций в проге
siglongjmp() - осуществляет переход на одну из отмеченных позиций
т.е. развитие идеи 5й проги 4й лабы.

Программные каналы - современные Юникс и Линукс сис-мы поддерживают 2 канала, имен и неимен каналы. (имен каналы mknod p)
Имена файлов в юникс не явл их идентификаторами, Юникс поддерживает дерево каталогов(иерархическое хранение файлов)

В классик Юниксе не было именованных прог. каналов. Они появились намного позже. У такого канала нет имени, у него есть только дескриптор. Программные канал являются буферами сис-й области
Буфера хар-я на 3х уровнях
1) сис области памяти(процесс не может выйти за своё адресное пространство, в результате не может обратиться к другому процессу)
при переполнении сис памяти, буфера со старшим временем, переписываются на диск, при этом юзаются обычные функции работы с файлами, если процесс пытается записать больше 4096 байтов, труба буферизуется во времени.
Процесс пытающийся записать больше 4096, блочится до тех пор пока все данные не будут прочитаны. т.е. сис вызов write будет успешен если труба пуста, и заблочен если полна,  read - успешен при полной трубе, и заблочен при пустой трубе.
//На экзе ответ на трубы - код проги создание неименованного канала(pipe).  
mknode(name,IFIFO|ACCESS,0);
mknode(mp,IFIFO|0666,0);
2)Если переполнена перепись на диск
3) во времени(всё выше в пункте 1)

Очереди сообщений. Являются очень интересным, специфик методом взаимодействия. Программный канал - потоковый тип передачи. Если смс получено то оно перестаёт существовать. 


Новую запись в очереди и помещает его в хвост указанной очереди. В каждой такой записиси указывается тип, размер и указатель в которой фактически находится текст смс
Текст смс copy из пространства пользователя в пространство ядра системы, после этого процесс отправитель может завершиться. Само смс остаётся доступным для других процессов. Когда какой-то процесс выбирает смс из очереди, ядро копирует текст смс в адресное пространство пользователя. Т.е. 2 копирования. В отлии от разделяемой памяти, где процесс может обратиться непосредственно к ***** процессу. 
Процесс может взять смс разными способами:
1)самое старое смс FIFO(смс будет в голове) 
2)Если идентификатор смс совпадает с тем, кот.  указал процесс. Если есть несколько смс с таким идентификатором, то берем самое старое.
3)Процесс может взять смс чиловое значение типа которого есть минимум из минимума, или равно значению указанному процом. Берем самое старое

Пример:
#include <stdio.h>
#include <string.h>
#include <sys/msg.h>
#ifdef MSGMAX
#define MSGMAX 1024
#endif

struct mbuf{
long type;
char mtext[MSGMAX];
}mobj={15, "Hello"}

int main(){
int fd=msgget(100,IPC_CREATE|IPC_EXCL|0642);
if (fd ==-1||msgsnd(fd &mobj,strlen(mobj.mtext)+1, IPC_NOWAIT))
	perror("msg");
	return 0;
}
							!!!!УВАГА!!! ВАЖНЫЕ МоМЕНТЫ!!!!!
При передаче смс есть 3 блокировки
1)Посылка
2)Обработка
3)Приём
Возникнут в определенных условиях, когда процесс заинтересован в результате смс.
							!!!!УВАГА!!! ВАЖНЫЕ МоМЕНТЫ!!!!!
То как процы общаются завистит от протокола воздействия. 


